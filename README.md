# HTML5MusicPlayer

### 在线演示地址：http://backgroudmusic.sinaapp.com/audio.html

### 申明：
1. 播放器部分后台代码为朱晓鸣老师微信开发教程中的demo，感谢朱老师的分享。
2. 示例中所有音乐资源均来自网易云音乐，版权归云音乐及各自音乐人所有。

### tastList：

1. 重构播放器结构，模仿网易云音乐播放器风格;
2. 增加音乐搜索模块;
2. 增加歌词显示;
3. 增加播放进度控制;
4. 增加音量控制；
5. 增加播放器动画;
6. 修复缓存加载错误问题;
7. 修复歌手信息无法获取问题。

### 关于歌词的实现方案：

> 通过云音乐的API获取的通常是这样的：
```
[00:00.00] 作曲 : 叶圣涛 [00:01.00] 作词 : 吴梦知 [00:03.240]曹格 :宝贝 跟爸爸一起唱歌哦 [00:05.880]Joe&Grace :Ok [00:07.690]曹格 :啦啦啦 啦啦啦 啦啦啦啦啦
```


> 其实在很久以前就很好奇音乐软件的歌词是怎么实现的，以前是毫无头绪，但当看到获取到歌词字段的时候，突然发现，奥，原来是这样子。

> 既然人家已经把歌词的格式定制好了，那么要实现歌词功能也就没有那么难了。

1. 首先想到的要将歌词数据转换成`时间 - 文本`这样的键值对数组。具体实现的话只需利用String的split方法进行一系列处理即可。

2. 得到`时间 - 文本`数组后，还有一项工作要做，因为歌词里面的时间格式是`[XX:XX.XX]`，所以要将其转换成代码可以识别的时间格式。在这里可以取整数秒作为键值。

3. 下面就只需用setInterval设置计时器，同样选取1s作为最小间隔，然后在计时器执行函数中比对currentTime与上面数组的键值来更新歌词。

4. 最后还要在自动播放下一首以及主动切换歌曲是调用clearInterval来结束前一首的计时器。一开始的时候没意识到这点，结果播放下一首时，前一首和当前曲目的歌词就一起显示了。

### 优化：

> 到上面基本的歌词功能就已经实现了，但作为一个对音乐无比热爱对听歌无比苛刻的人，一点点不起眼的问题就让我感到不适。

1. **切歌时歌词卡在上一首歌的最后一句**

 	云音乐的歌词总的来说可以分为三种：
		
 	*  无`[00:00.00]`时间点： ` [00:03.240]曹格 :宝贝 跟爸爸一起唱歌哦 [00:05.880]Joe&Grace :Ok [00:07.690]曹格 :啦啦啦 啦啦啦 啦啦啦啦啦 `
 	*  有`[00:00.00]`时间点： `[00:00.00] 作曲 : 叶圣涛 [00:01.00] 作词 : 吴梦知 [00:03.240]曹格 :宝贝 跟爸爸一起唱歌哦 [00:05.880]Joe&Grace :Ok [00:07.690]曹格 :啦啦啦 啦啦啦 啦啦啦啦啦 `
 	*  歌词前附带额外信息：`[ti:le papillon] [ar:nicolas err ra] [00:14.512]Pourquoi les poules pondent des oeufs? [00:18.563]Pour que les oeufs fassent des poules. [00:21.264]Pourquoi les amoureux s ’embrassent? `
 	
	对于第二种的歌词是不存在上述问题的，因为一开始播放时会立即更新歌词显示，而第一种则会出现上述问题。

	对于这个问题最简单方法是解析歌词是判断一下是否有`[00:00.00]`时间点，如果没有就将歌名和歌手赋值给它；这样对于第二种类型的歌词问题就得到了解决，但是对于第三种附带的额外信息部分压根就会被忽略掉，这样的话还得增加一个判断，如果是第三种类型的歌词就将附带信息赋值给[00:00.00]`时间点。

	不过通过观察，我发现这些额外字段其实就包含有歌名信息，这样只需应用其中的一种就可以了。

2. **进度跳转后歌词卡在跳转前状态**

	乍一看起来这个问题跟上一个是同一个问题，但仔细一想这个要麻烦的多，因为进度的跳转涉及到一些事件的触发。上一个问题可以直接在setInterval计时器的函数中直接添加`if`判断即可，而这一个是要响应事件的。同样是操作歌词展现部分的HTML，一个是通过计时器，一个是通过事件。
	
	通过解析得到数组的值也是有三种：undefined、空字符串、歌词字符串。

	以下面歌词为例：

	```
	[00:03.240]曹格 :宝贝 跟爸爸一起唱歌哦
	```
	
	1s、2s值为undefined、3s为各自对应的,而我们平时听的有些歌中间会有没歌词的旋律部分，这一部分的值便是空字符串。

	而在更新歌词时，遇到undefined时会不更改HTML，遇到空字符串时歌词部分就显示为空。

	这样当你跳转进度时如果正好跳转到第二、三种值时是没有问题的，但当正好跳转到一个undefined时，由于没有更改HTML，所以显示还是跳转前的歌词。表现出来的现象就是跳转到某个时刻时，唱的是当前时刻歌词，但显示的还是跳转前时刻的歌词，只有唱到下一句时，歌词才会正常显示。

### 遗留问题：
1. 更新歌词时有两段代码可以操作同一处HTML，虽然目前为止没发现什么问题，但是总觉得如果两段代码同时操作一处地方可能会出现问题。感觉就跟《操作系统》里面讲的进程什么的类似，对于浏览器如何解释执行代码这块还是不太清楚。

2. 更新歌词的时候选择的更新频率是1s,也就是说歌词的真实时间与歌词显示时间会有最长1s的误差。我观察了一下，基本上没啥问题，偶尔会有极短的延时，但是如果不是死盯歌词，全神贯注的话无法发觉的。但是无法察觉并不代表不存在，确实是有问题。问题就在那，你发现不发现，问题就是问题。 
   
### @TODO:

1. **判定媒体内容加载情况时在IE下无效，导致缓存进度在IE无法显示;不同浏览器、网络状况下仍旧会出现不可预见问题。**

   * 错误信息：`Failed to execute 'end' on 'TimeRanges': The index provided (0) is greater than or equal to the maximum bound (0)`
 
   * 处理：
 	
 		开始时把更新缓存进度的函数绑定到progress事件，希望借助progress的不断触发来实现缓存条更新，结果会显示如上错误。
 
 		于是把`obj.buffered.end(0)`打印了一下，发现并不是会一直报错，当音乐播放一段时间后可以输出结果。感觉问题出在了事件触发的时间上。在一开始触发progress时，此时还没有进行缓冲，`buffer.end(0)`是无法获取的，所有才会出现如上错误。
 
 		在audio所有事件中，除了progress就只有timeupdate是会不停触发的，但timeupdate是与currentTime相关的，更适合用于播放条的更新而不是缓冲条;还有一种办法就是利用setInterval不停地调用缓冲更新函数，但这样就跟audio的事件没有任何关联了...

  		之所以出问题是因为在前期触发progress时没有缓冲，那么可以在调用更新缓冲函数前加一个判断，让它只有在可以获取`buffered.end(0)`时才调用。
  
  		audio的readyState属性指定的是当前已经加载的媒体内容，可以通过它的值来进行判断，在readyState值为0或1时，是没有加载媒体内容的，所以要在其后才可以调用更新缓存函数。在调用更新缓冲函数前加一个if判断来判断下readyState就可以了。
  
 		 ```
              if (obj.readyState !== 0 && obj.readyState !== 1) {
                onSoundBuffering();
            }
 		 ```
  
  		这样便不会报错了，但是在Chrome下还是有一些奇怪的现象，打印readyState会发现有些时候莫名出现一连串0，明明已经开始播放了，readyState一直是0是什么鬼？(貌似是在歌曲已经播放过一次，本地已经有缓存的时候出现的多)
 

 
2. **暂停时无法保持动画当前位置，尝试animation-play-state：pause 暂停动画，但元素样式还是也会回到原始状态。**

3. **页面布局方面比较仓促，由于核心是在js上，所有布局方面没有考虑太多，响应式这一块做的比较爆炸，只是应用了一些简单的media query，还有待完善。**

4. **歌词数据前的莫名字段无法显示：** 
	* 问题
		
		> 今天无意间随便点了首个,结果发现歌词前面竟然有一些奇怪的字段
	
		```
		[ti:le papillon] [ar:nicolas err ra] [00:14.512]Pourquoi les poules pondent des oeufs? [00:18.563]Pour que les oeufs fassent des poules. [00:21.264]Pourquoi les amoureux s ’embrassent? 
		```
	
		这是什么鬼?爆炸啊,处理歌词的时候是按照`[时间]XXXX`处理的;`[ti:le papillon]`是我搜的歌的名字，但是这些信息通常也是要跟在时间后面，像这样:

		`[00:00.00] 作曲 : 叶圣涛 [00:01.00] 作词 : 吴梦知 [00:03.240]曹格 :宝贝 跟爸爸一起唱歌哦 [00:05.880]Joe&Grace :Ok [00:07.690]曹格 :啦啦啦 啦啦啦 啦啦啦啦啦 `

		果然，一首歌包含太多数据，怪不得抓的云音乐一首歌的JSON对象要几百行。

	* 可行的解决办法：
		
		可以跟上面的《爸爸去哪儿》那首歌一样，先判定歌词数据是不是以`[XX:XX.XX]`开头，如果不是就在前面添加`[00:00.00]`,然后把那些莫名字段赋给这个时间点。

		不过这样还是有问题的，像`[ti:le papillon] [ar:nicolas err ra]`这样简短的字段可以采用上面的方法，可是如果莫名字段字符很多的话`[00:00.00]`这一个时间点是根本显示不过来的。

		幸好随机找了几首歌发现前面的莫名字段都不会很长，不过没用发现并不代表没有这种可能性，看来有时间还得好好分析云音乐的歌曲信息。


### 一些收获（所有结论皆是在网络状态良好（20M宽带）下得出）：
1. 关于readyState：

   	Chrome通常会在加载第一首歌曲时才会有0值，而后切换歌曲时直接跳转4值;而Firefox在播放每首歌曲时都会存在0值，而后调至4值。
   在网速良好时，二者的readyState都不会存在1/2/3值。

2. 关于HVAE_ENOUGH_DATA：
   
   	官方对HVAE_ENOUGH_DATA的描述为：所有媒体内容都已经加载完毕，但Chrome与Firefox貌似并没有这样处理，二者都会在缓冲内容未未到1    00%时将readyState值变为4。

3. 关于progress：
   
   	官方描述中称此事件会每秒触发2~8次，在Chrome中，当加载足够内容时，progress会停止，然后触发suspend，暂时停止下载;而Firefox似乎比较心急，当前一首歌曲播放时，后面的歌曲会直接缓冲完毕，也就是说并没有像Chrome一样触发suspend,暂停下载，而是一口气缓冲完。

4. 关于编程：
	
	之前只是看书，写写简单的代码，到真正做个东西的时候，突然发现有时候思路比具体代码更重要。写代码之前先搞明白要做什么？思路是怎样？特别是像audio这样的多媒体编程，其规范本身就已经很复杂，浏览器厂商还各整各的一套东西就更复杂了。

	不过值得欣慰是发现书没有白看，基础还是很重要的，中间遇到很多问题仔细想想还是JavaScript Core的问题，突然发现有些问题可以用学到的知识解决了，还是很高兴的。